//
//  SynthParameter.h
//  MRP
//
//  Created by Jeff Gregorio on 7/28/14.
//  Copyright (c) 2014 Jeff Gregorio. All rights reserved.
//

#ifndef __MRP__SynthParameter__
#define __MRP__SynthParameter__

#include <iostream>

//! Ramped Synth Parameter
/*!
    Used for synth prameters that shouldn't change in noticably discrete intervals (i.e. from infrequent parameter updates via a laggy UI or OSC messages). Setting target parameter values with the SynthParamter::setValue() method allows parameters to be ramped linearly over a specified duration until they reach the target value by calling SynthParameter::ramp() to increment/decrement the value for a single audio sample, or SynthParameter::ramp(int nSamples) to ramp for a specified number of samples. 
 
    Values may be set directly (without ramping) using overloaded operators {=, +=, -=, *=, /=}  with a left-hand operand of type SynthParameter, and right-hand operands of type SynthParameter or native float.
 
    Parameter values can be constrained by calling SynthParameter::setRange(float minVal, float maxVal). Attempting to set a value larger than the max will set the value to the max. Attempting to set a value smaller than the min will set the value to the min. No warning messages are generated by attempting to set outside the range. By default the range is set to the min and max representable by a float type.
 
    Float values may be returned using overloaded operators {+, -, *, /} with SynthParameter types on both left- and right-hand sides, or a SynthParameter type and a native float type on either side.
 
    Boolean comparison operators {==, !=, <, >, <=, >=} are also implemented for SynthParameter types on both left- and right-hand sides, or a SynthParameter type and a native float type on either side.
 
    To do: logarithmic ramping.
*/
class SynthParameter {
    
    std::string _name;      // Parameter name
    
    float _fs;              // Sampling rate
    
    float _value;           // Current parameter value
    float _targetValue;     // Target value
    float _valueStep;       // Step size per sample to reach target value
    float _rampDuration;    // Time to reach target value in seconds
    
    float _maxValue;        // Value range constraints
    float _minValue;
    
    /* External callback method/function pointer called whenever this parameter value changes (including ramp updates). Useful for parameters like filter cutoff/Q, where intermediate parameters and coefficients must be recomputed when the filter parameters change. */
    typedef void (*ParameterChangeListener) (float targetVal, void *userData);
    void *_parameterChangeListener;
    void *_parameterChangeListenerUserData;
    bool _hasParameterChangeListener;
    
public:
    
#pragma mark - Constructors/Desctructors
    SynthParameter();
    SynthParameter(std::string name, float fs, float value, float rampDuration);
    ~SynthParameter() {};
    
#pragma mark - Getters
    std::string name() { return _name; }
    float sampleRate() const { return _fs; }                  // Get the sampling rate
    float value() const { return _value; }                    // Query the current value
    float minVal() const { return _minValue; }
    float maxVal() const { return _maxValue; }
    
#pragma mark - Setters
    void namePrepend(std::string prefix);
    void setSampleRate(const float fs);                 // Set the sampling rate
    void setValue(const float value);                   // Set a new target value
    void setValue(const SynthParameter param);
    void setRampDuration(const float rampDuration);     // Set the time in seconds to reach target values
    void setRange(float minVal, float maxVal);          // Value constraints
    
    void setParameterChangeListener(ParameterChangeListener callback, void *userData);
    void removeParameterChangeListener();
    
#pragma mark - Updates
    void ramp();                            // Update if _value != _targetValue (single sample)
    void ramp(int nSamples);                // Update if _value != _targetValue (multiple samples)
    
#pragma mark - Overloaded Operators (Members)
    SynthParameter& operator=(const float value);
    SynthParameter& operator=(const SynthParameter param);
    SynthParameter& operator+=(const float value);
    SynthParameter& operator+=(const SynthParameter param);
    SynthParameter& operator-=(const float value);
    SynthParameter& operator-=(const SynthParameter param);
    SynthParameter& operator*=(const float value);
    SynthParameter& operator*=(const SynthParameter param);
    SynthParameter& operator/=(const float value);
    SynthParameter& operator/=(const SynthParameter param);
};

#pragma mark - Overloaded Operators (Non-Members)
inline bool operator==(const SynthParameter& left, const SynthParameter& right) { return left.value() == right.value(); }
inline bool operator!=(const SynthParameter& left, const SynthParameter& right) { return !operator==(left, right); }
inline bool operator< (const SynthParameter& left, const SynthParameter& right) { return left.value() < right.value(); }
inline bool operator> (const SynthParameter& left, const SynthParameter& right) { return operator< (right, left); }
inline bool operator<=(const SynthParameter& left, const SynthParameter& right) { return !operator> (left, right); }
inline bool operator>=(const SynthParameter& left, const SynthParameter& right) { return !operator< (left, right); }

inline bool operator==(const float left, const SynthParameter& right) { return left == right.value(); }
inline bool operator!=(const float left, const SynthParameter& right) { return !operator==(left, right); }
inline bool operator< (const float left, const SynthParameter& right) { return left < right.value(); }
inline bool operator> (const float left, const SynthParameter& right) { return left > right.value(); }
inline bool operator<=(const float left, const SynthParameter& right) { return !operator> (left, right); }
inline bool operator>=(const float left, const SynthParameter& right) { return !operator< (left, right); }

inline bool operator==(const SynthParameter& left, const float right) { return left.value() == right; }
inline bool operator!=(const SynthParameter& left, const float right) { return !operator==(left, right); }
inline bool operator< (const SynthParameter& left, const float right) { return left.value() < right; }
inline bool operator> (const SynthParameter& left, const float right) { return operator< (right, left); }
inline bool operator<=(const SynthParameter& left, const float right) { return !operator> (left, right); }
inline bool operator>=(const SynthParameter& left, const float right) { return !operator< (left, right); }

inline float operator+(const SynthParameter& left, const SynthParameter& right) { return left.value() + right.value(); }
inline float operator-(const SynthParameter& left, const SynthParameter& right) { return left.value() - right.value(); }
inline float operator*(const SynthParameter& left, const SynthParameter& right) { return left.value() * right.value(); }
inline float operator/(const SynthParameter& left, const SynthParameter& right) { return left.value() / right.value(); }

inline float operator+(const float left, const SynthParameter& right) { return left + right.value(); }
inline float operator-(const float left, const SynthParameter& right) { return left - right.value(); }
inline float operator*(const float left, const SynthParameter& right) { return left * right.value(); }
inline float operator/(const float left, const SynthParameter& right) { return left / right.value(); }

inline float operator+(const SynthParameter& left, const float right) { return left.value() + right; }
inline float operator-(const SynthParameter& left, const float right) { return left.value() - right; }
inline float operator*(const SynthParameter& left, const float right) { return left.value() * right; }
inline float operator/(const SynthParameter& left, const float right) { return left.value() / right; }

#endif /* defined(__MRP__SynthParameter__) */
